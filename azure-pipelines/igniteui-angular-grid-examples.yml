trigger:
  branches:
    include:
    - vnext
    - master

# This pipeline is meant to build specific branches for deployment. It's not meant to be a part of PR validation.
pr: none

parameters:
- name: isVerbose
  displayName: 'Get verbose output from steps - where configurable'
  type: boolean
  default: false
- name: shouldCleanPostExecution
  displayName: 'Clean all pipeline dirs after the pipeline finishes?'
  type: boolean
  default: true

name: $(BuildDefinitionName)_$(Year:yyyy).$(Month).$(DayOfMonth)$(Rev:.r)

stages:
- stage: Build
  pool:
    name: BuildAgentOnPrem
    demands: npm
  jobs:
  - job: BuildSamples
    steps:
      - checkout: 'self' 
        clean: true

      - task: NodeTool@0
        displayName: 'Install Node'
        inputs:
          versionSource: 'spec'
          versionSpec: '18.x'

      - task: Npm@1
        displayName: 'npm install --legacy-peer-deps'
        inputs:
          command: custom
          workingDir: '$(Build.SourcesDirectory)'
          customCommand: 'install --legacy-peer-deps'

      - task: Npm@1
        displayName: 'Register licensed npm registry in .npmrc'
        inputs:
          command: 'custom'
          workingDir: '$(Build.SourcesDirectory)'
          customCommand: 'config -L project set @infragistics:registry=https://packages.infragistics.com/npm/js-licensed/'
          customEndpoint: 'internal proget'

      - task: Npm@1
        displayName: 'npm run build:ci'
        inputs:
          command: custom
          workingDir: '$(Build.SourcesDirectory)'
          customCommand: 'run build:ci'

      - task: PowerShell@2
        displayName: 'Verify artifact directory exists'
        inputs:
          targetType: 'inline'
          script: |
            $artifactPath = "$(Build.SourcesDirectory)\dist\grid-demos\browser"
            if (Test-Path $artifactPath) {
              Write-Host "Directory exists: $artifactPath"
            } else {
              Write-Error "Directory does not exist: $artifactPath"
            }

      - task: PowerShell@2
        displayName: 'Verify artifact contents'
        inputs:
          targetType: inline
          script: |
            $artifactPath = "$(Build.SourcesDirectory)\dist\grid-demos\browser"
            if (Test-Path $artifactPath) {
              Get-ChildItem -Path $artifactPath -Recurse | ForEach-Object {
                Write-Host "File: $($_.FullName)"
              }
            } else {
              Write-Error "Directory does not exist: $artifactPath"
            }

      - task: PublishPipelineArtifact@1
        displayName: 'Publish pipeline artifact'
        inputs:
          targetPath: '$(Build.SourcesDirectory)\dist\grid-demos\browser'
          artifact: 'dist.grid-demos.browser'
          publishLocation: 'pipeline'

      - task: PowerShell@2
        displayName: 'package.json - trial to licensed'
        inputs:
          targetType: 'inline'
          script: |
            $filePath = "$(Build.SourcesDirectory)\package.json"
            $trialStringsToReplace = @(
                [pscustomobject]@{ Pattern = '(\"igniteui-angular\")'; Replacement = '"@infragistics/igniteui-angular"' },
                [pscustomobject]@{ Pattern = '(\"igniteui-angular-charts\")'; Replacement = '"@infragistics/igniteui-angular-charts"' }
            )
            
            # Be careful with Get-Content and the replace operator.
            # This script's verbosity relies on reading the file as a string array so we can display the found matches.
            # If you read the file with -Raw (a.k.a a single string), then the match output object is a Boolean - not a String.
            $fileContents = Get-Content -Path $filePath 
            
            $trialStringsToReplace | ForEach-Object {
                $matches = $fileContents -match $_.Pattern 
            
                if([string]::IsNullOrEmpty($matches)) {
                    throw $("No matches for $($_.Pattern) in $filePath !!!")
                }
                else {
                    Write-Output "Found the following matches for $($_.Pattern) in $filePath. To be replaced with $($_.Replacement)"
                    Write-Output $matches
                }
                
                $fileContents = $fileContents -replace $_.Pattern, $_.Replacement 
                Set-Content -Path "$filePath" -Value $fileContents -Force
            }

      - task: PublishPipelineArtifact@1
        inputs:
          targetPath: '$(Build.SourcesDirectory)/package.json'
          artifact: 'packagejson'
          publishLocation: 'pipeline'

      - ${{ if eq(parameters.shouldCleanPostExecution, true) }}:
        - task: PostBuildCleanup@4